# выполнили Мулюкина Е.В., гр. 4384 и Экажев Р.Х., гр. 4384

class Natural:
    def __init__(self, num: str):
        num = list(map(int, num))
        while len(num) > 1 and num[0] == 0:  # удаление незначащих нулей
            num = num[1:]
        self.num = num
    def __str__(self):
        return ''.join(map(str, self.num))
    
    # 1. Сравнение натуральных чисел: 2 - если первое больше второго, 0, если равно, 1 иначе
    def COM_NN_D(self, other) -> int:
        # Сравнение по длине чисел
        # Если длина первого числа больше длины второго числа, то первое больше второго
        # возвращаем 2
        if len(self.num) > len(other.num):
            return 2
        # Если длина первого числа меньше длины второго числа, то первое меньше второго
        # возвращаем 1
        elif len(self.num) < len(other.num):
            return 1
    
        # Если длины чисел равны, то сравниваем по цифрам
        # Проходимся циклом по всем разрядам чисел слева направо
        for i in range(len(self.num)):
            # Если цифра разряда первого числа больше цифры того же разряда второго числа,
            # то первое число больше второго, возвращаем 2
            if self.num[i] > other.num[i]:
                return 2
            # Иначе если цифра разряда первого числа меньше цифры того же разряда второго числа,
            # то первое число меньше второго, возвращаем 1
            elif self.num[i] < other.num[i]:
                return 1
    
        # Если все цифры равны, то и числа равны, возвращаем 0
        return 0

    # 2. Проверка на ноль: если число не равно нулю, то «да» иначе «нет»
    def NZER_N_B(self):
        # Если число имеет только один разряд и этот разряд равен 0,
        # то число равно нулю, возвращаем 'нет'
        if len(self.num) == 1 and self.num[0] == 0:
            return 'нет'
        # Иначе число не ноль, возвращаем 'да'
        return 'да'

    # 3. Добавление 1 к натуральному числу
    def ADD_1N_N(self):
        # Создаем копию числа для безопасного изменения
        num = self.num.copy()
        
        # Идем с конца к началу числа (от младших разрядов к старшим)
        for i in range(len(num)-1, -1, -1):
            # Если текущая цифра меньше 9, просто увеличиваем её на 1
            # и завершаем алгоритм, возвращая результат (перенос не требуется)
            if num[i] < 9:
                num[i] += 1
                return Natural(''.join(map(str, num)))
            # Если цифра равна 9, заменяем её на 0
            # и продолжаем обработку следующего (более старшего) разряда
            # (эквивалентно переносу 1 в следующий разряд)
            else:
                num[i] = 0
        
        # Если дошли до этого момента, значит все разряды были 9
        # и произошел перенос через всё число
        # В этом случае добавляем 1 в начало (например, 999 → 1000)
        return Natural('1' + ''.join(map(str, num)))

    #4. Сложение натуральных чисел
    def ADD_NN_N(self, other):
        # Переворачиваем оба числа для удобства (младшие разряды в начале)
        # Это позволяет обрабатывать числа с младших разрядов к старшим
        num1 = self.num[::-1]  # первое число в перевернутом виде
        num2 = other.num[::-1]  # второе число в перевернутом виде
        
        # Определяем максимальную длину среди двух чисел
        max_len = max(len(num1), len(num2))
        
        # Дополняем оба числа нулями до одинаковой длины
        # Это нужно для поразрядного сложения без проверок на существование разрядов
        num1 += [0] * (max_len - len(num1))
        num2 += [0] * (max_len - len(num2))
        
        result = []  # Результат сложения (в перевернутом виде)
        carry = 0    # Перенос из предыдущего разряда (изначально равен 0)
        
        # Складываем числа поразрядно
        for i in range(max_len):
            # Сумма цифр текущего разряда с учетом переноса
            digit_sum = num1[i] + num2[i] + carry
            # В результат записываем младшую цифру суммы (остаток от деления на 10)
            result.append(digit_sum % 10)
            # Вычисляем перенос для следующего разряда (целая часть от деления на 10)
            carry = digit_sum // 10
        
        # Если после обработки всех разрядов остался перенос,
        # то добавляем его как новый старший разряд
        if carry > 0:
            result.append(carry)
        
        # Переворачиваем результат обратно для правильного представления числа
        # (старшие разряды в начале, младшие в конце)
        return Natural(''.join(map(str, result[::-1])))

    # 5. Вычитание из первого большего натурального числа второго меньшего или равного
    def SUB_NN_N(self, other) -> 'Natural':
        # Проверяем соотношение чисел
        compare = self.COM_NN_D(other)
        # Если первое число меньше второго, возвращаем ошибку (результат отрицательный)
        if compare == 1:
            raise ValueError("Первое число должно быть больше или равно второму")
        # Если числа равны, то результат вычитания равен 0
        elif compare == 0:
            return Natural('0')  

        # Переворачиваем оба числа для удобства (младшие разряды в начале)
        # Это позволяет обрабатывать числа с младших разрядов к старшим
        a = self.num[::-1]  # Уменьшаемое в перевернутом виде
        b = other.num[::-1]  # Вычитаемое в перевернутом виде
        
        # Дополняем вычитаемое нулями до одинаковой длины с уменьшаемым
        # Это нужно для поразрядного вычитания без проверок на существование разрядов
        b += [0] * (len(a) - len(b))

        result = []  # Результат вычитания (в перевернутом виде)
        borrow = 0   # Заём из следующего разряда (изначально равен 0)

        # Вычитаем числа поразрядно (начиная с младшего)
        for i in range(len(a)):
            # Вычитаем заём из текущей цифры уменьшаемого
            current_digit = a[i] - borrow
            
            # Если после вычитания заёма цифра меньше цифры вычитаемого,
            # нужно занять из следующего разряда
            if current_digit < b[i]:
                current_digit += 10
                borrow = 1
            else:
                borrow = 0

            # Вычитаем цифру вычитаемого и добавляем разность в результат
            digit_diff = current_digit - b[i]
            result.append(digit_diff)

        # Убираем ведущие нули из результата
        # (в перевернутом виде старшие разряды в конце массива)
        while len(result) > 1 and result[-1] == 0:
            result.pop()
        
        # Переворачиваем результат обратно для правильного представления числа
        # (старшие разряды в начале, младшие в конце)
        result.reverse()
        return Natural(''.join(map(str, result)))

    # 6. Умножение натурального числа на цифру
    def MUL_ND_N(self, digit: int):
        # Проверяем, что умножается именно на цифру (от 0 до 9)
        if not (0 <= digit <= 9):
            raise ValueError('Данные не являются цифрой!')
        
        # Если цифра равна 0 или исходное число равно 0, 
        # то результат умножения всегда будет 0
        if digit == 0 or (len(self.num) == 1 and self.num[0] == 0):
            return Natural('0')

        res_digits = []  # Результат умножения (в перевернутом виде)
        carry = 0        # Перенос из младшего разряда в старший (изначально равен 0)

        # Проходим по цифрам исходного числа в обратном порядке
        # (от младших разрядов к старшим)
        for i in range(len(self.num) - 1, -1, -1):
            # Умножаем текущую цифру на заданную цифру и добавляем перенос
            current_digit = self.num[i]
            product = current_digit * digit + carry
            
            # В результат записываем младшую цифру произведения (остаток от деления на 10)
            res_digits.append(product % 10)
            # Вычисляем перенос для следующего разряда (целая часть от деления на 10)
            carry = product // 10
        
        # Если после обработки всех разрядов остался перенос,
        # то добавляем его как новый старший разряд
        if carry > 0:
            res_digits.append(carry)
        
        # Переворачиваем результат обратно для правильного представления числа
        # (старшие разряды в начале, младшие в конце)
        res_digits.reverse()
        res_str = ''.join(map(str, res_digits))

        return Natural(res_str)
    
    # 7. Умножение натурального числа на 10^k, k-натуральное (недлинное)
    def MUL_Nk_N(self, k: int):
        # Проверяем, что степень k является натуральным числом (неотрицательным)
        if k < 0:
            raise ValueError('Число k должно быть натуральным!')
        
        # Умножение на 10^k эквивалентно добавлению k нулей в конец числа
        # Это следует из позиционной системы счисления:
        # число × 10^k = число, сдвинутое на k разрядов влево
        return Natural(str(self) + '0' * k)

    # 8. Умножение натуральных чисел
    def MUL_NN_N(self, other) -> 'Natural':
        # Если хотя бы одно из чисел равно нулю, то результат умножения будет равен нулю
        if (len(self.num) == 1 and self.num[0] == 0) or (len(other.num) == 1 and other.num[0] == 0):
            return Natural('0')

        # Первоначально результат равен нулю
        # Будем накапливать сумму частичных произведений
        result = Natural('0')

        # Переворачиваем второе число для обработки с младших разрядов к старшим
        # Это позволяет умножать на цифры, начиная с единиц, затем десятки, сотни и т.д.
        num_2 = other.num[::-1]
        
        # Проходим по всем цифрам второго числа (от младших разрядов к старшим)
        for i, digit in enumerate(num_2):
            # Умножаем первое число на текущую цифру второго числа
            # Это дает частичное произведение для данного разряда
            part_res = self.MUL_ND_N(digit)
            
            # Сдвигаем частичное произведение влево на i разрядов
            # (умножаем на 10^i) для учета позиции текущей цифры во втором числе
            shifted_res = part_res.MUL_Nk_N(i)
            
            # Добавляем сдвинутое частичное произведение к общему результату
            # Это соответствует сложению частичных произведений в столбик
            result = result.ADD_NN_N(shifted_res)

        return result

    #9. Вычитание из натурального, умноженного на цифру для случая с неотрицательным результатом
    def SUB_NDN_N(self, other, digit):
        # Умножаем второе число на заданную цифру
        # Получаем произведение, которое будем вычитать из первого числа
        product = other.MUL_ND_N(digit)
        
        # Проверяем, что первое число больше или равно произведению
        # Это необходимо, чтобы результат вычитания был натуральным числом
        if self.COM_NN_D(product) == 1:
            raise ValueError("Первое число должно быть больше или равно второму, умноженному на цифру")
        
        # Вычитаем из первого числа произведение второго числа на цифру
        # Результатом будет натуральное число (разность)
        return self.SUB_NN_N(product)

    #10. Вычисление первой цифры деления большего натурального на меньшее, домноженное на 10^k, 
    #    где k - номер позиции этой цифры (0 - единицы, 1 - десятки и т.д.)
    def DIV_NN_Dk(self, other):
        # Определяем начальную позицию k для первой цифры частного
        # k = длина делимого - длина делителя (максимальная возможная позиция)
        k = len(self.num) - len(other.num)
        
        # Корректируем позицию k, с которой начинается частное, если нужно
        if k >= 0:
            # Дополняем делитель k нулями (умножаем на 10^k)
            # Это соответствует сдвигу делителя влево на k разрядов
            other_shifted = other.MUL_Nk_N(k)
            # Если делимое стало меньше "дополненного" делителя,
            # то это значит, что частное начинается с разряда на 1 меньше
            # (корректируем k уменьшением на 1)
            if self.COM_NN_D(other_shifted) == 1:
                k -= 1
        
        # Если после корректировки k стало отрицательным,
        # это означает, что длина делимого меньше длины делителя
        # В этом случае частное = 0, возвращаются цифра = 0, позиция = 0
        if k < 0:
            return 0, 0

        # Изначально считаем цифру равной 0
        digit = 0
        # Перебираем возможные цифры от 1 до 9 в цикле
        # Находим максимально возможную цифру для найденной позиции k
        for d in range(1, 10):
            # Вычисляем произведение: (делитель × 10^k) × текущая цифра
            # Это соответствует частичному произведению для текущей позиции
            product = other.MUL_Nk_N(k).MUL_ND_N(d)
            # Если произведение НЕ БОЛЬШЕ делимого (≤ делимого),
            # то текущая цифра допустима, запоминаем её
            if product.COM_NN_D(self) != 2:
                digit = d
            else:
                # Если произведение стало больше делимого,
                # предыдущая цифра была максимально возможной - выходим из цикла
                break
        
        # Возвращаем первую цифру частного и её позицию k
        # (k - степень 10, на которую нужно умножить цифру)
        return digit, k

    #11. Неполное частное от деления первого натурального числа на второе с остатком (делитель отличен от нуля)
    def DIV_NN_N(self, other):
        # Если делитель равен нулю, то выводим ошибку деления на 0
        if other.COM_NN_D(Natural('0')) == 0:
            raise ValueError('Деление на ноль невозможно!')

        # Сравнение делимого и делителя
        comparison = self.COM_NN_D(other)
        # Если делимое меньше делителя, то частное равно 0
        if comparison == 1:
            return Natural('0')
        # Если делимое и делитель равны, то частное равно 1
        if comparison == 0:
            return Natural('1')

        # Максимальная возможная длина частного = длина делимого - длина делителя + 1
        max_length = len(self.num) - len(other.num) + 1
        # Создаем массив для хранения цифр частного, инициализированный нулями
        # Индексы массива соответствуют позициям разрядов (0 - единицы, 1 - десятки и т.д.)
        result_digits = [0] * max_length
        
        # Изначально текущий остаток равен делимому (в процессе деления остаток будет уменьшаться)
        current_dividend = Natural(str(self))

        # Пока текущий остаток >= делителя, продолжаем деление
        # (если остаток станет меньше делителя, деление завершено)
        while current_dividend.COM_NN_D(other) != 1:
            # Вычисляем следующую цифру частного и её позицию
            # методом DIV_NN_Dk (деление с определением позиции)
            digit, k = current_dividend.DIV_NN_Dk(other)
            
            # Если найденная цифра равна 0, это означает, что деление завершено
            # (больше нет ненулевых цифр в частном)
            if digit == 0:
                break

            # Записываем найденную цифру в частное на соответствующую позицию k
            # Позиция k определяет, в каком разряде должна стоять эта цифра
            result_digits[k] = digit
            
            # Вычисляем произведение, которое нужно вычесть из текущего остатка:
            # (делитель × цифра) × 10^k
            # Это соответствует частичному произведению для текущего шага деления
            temp = other.MUL_ND_N(digit).MUL_Nk_N(k)
            # Вычитаем это произведение из текущего остатка
            current_dividend = current_dividend.SUB_NDN_N(temp, 1)
            
            # Если после вычитания текущий остаток стал нулевым,
            # деление завершено (делится нацело)
            if current_dividend.NZER_N_B() == 'нет':
                break

        # Убираем ведущие нули из результата
        # (в перевернутом виде старшие разряды в конце массива)
        while len(result_digits) > 1 and result_digits[-1] == 0:
            result_digits.pop()
            
        # Разворачиваем массив цифр частного
        # До этого момента результат хранился в формате [единицы, десятки, сотни, ...]
        # Теперь нужно преобразовать к нормальному виду: [старшие разряды, ..., младшие разряды]
        result_digits.reverse()
        return Natural(''.join(map(str, result_digits)))

    #12. Остаток от деления первого натурального числа на второе натуральное (делитель отличен от нуля)
    def MOD_NN_N(self, other):
        # Проверяем, что делитель не равен нулю
        if other.COM_NN_D(Natural('0')) == 0:
            raise ValueError('Деление на ноль невозможно!')

        # Вычисляем частное от деления первого числа на второе
        quotient = self.DIV_NN_N(other)
        
        # Далее в цикле вычисляем произведение, равное частное × делитель (изначально инициализировано нулём)
        # (получится максимальное число, не превосходящее делимого и делящееся на делитель)
        
        product = Natural('0')
        quotient_str = str(quotient)
        
        # Вычисляем произведение поразрядно
        # Проходим по всем цифрам частного от старшего разряда к младшему
        for i, digit_char in enumerate(quotient_str):
            digit = int(digit_char)
            # Если текущая цифра не равна нулю, вычисляем её вклад в произведение
            if digit > 0:
                # Умножаем делитель на текущую цифру частного
                temp = other.MUL_ND_N(digit)
                # Сдвигаем результат на соответствующее количество разрядов
                # (умножаем на 10 в степени позиции цифры)
                temp = temp.MUL_Nk_N(len(quotient_str) - i - 1)
                # Добавляем полученное значение к общему произведению
                product = product.ADD_NN_N(temp)
        
        # Вычисляем остаток от деления:
        # остаток = делимое - (частное × делитель)
        remainder = self.SUB_NDN_N(product, 1)
        
        return remainder

    #13. НОД натуральных чисел
    def GCF_NN_N(self, other):
        # Создаем копии чисел для безопасной работы
        # Это предотвращает изменение исходных объектов
        a = Natural(str(self))
        b = Natural(str(other))

        # Проверяем, является ли одно из чисел нулем
        # Если a = 0, то НОД(a,b) = b (по определению НОД)
        if a.NZER_N_B() == "нет":
            return b
        # Если b = 0, то НОД(a,b) = a (по определению НОД)
        if b.NZER_N_B() == "нет":
            return a
        
        # Основной цикл алгоритма Евклида
        # Продолжаем, пока второе число b не станет равным нулю
        while b.NZER_N_B() == "да":
            # Сравниваем числа a и b
            comparison = a.COM_NN_D(b)
            
            # Если a < b, меняем числа местами
            # Это обеспечивает, что a всегда >= b для корректного деления
            if comparison == 1:  # a < b
                a, b = b, a
            # Если числа равны, то НОД найден (равен любому из чисел)
            elif comparison == 0:  # a == b
                return a

            # Вычисляем остаток от деления a на b
            # По алгоритму Евклида: НОД(a,b) = НОД(b, a mod b)
            temp = a.MOD_NN_N(b)
            # Обновляем значения: a становится b, b становится остатком
            a, b = b, temp

        # Когда b становится нулем, НОД содержится в a
        return a

    #14. НОК натуральных чисел
    def LCM_NN_N(self, other):
        # Вычисляем НОК по формуле: НОК(a,b) = (a × b) / НОД(a,b)
        return self.MUL_NN_N(other).DIV_NN_N(self.GCF_NN_N(other))

# Тестирование
def tests_for_naturales():
    # Создаем тестовые натуральные числа
    num1 = Natural("2")      # маленькое число
    num2 = Natural("25")     # двузначное число  
    num3 = Natural("999")    # большое число (три девятки)
    num4 = Natural("87")     # двузначное число
    num5 = Natural("0")      # ноль
    num6 = Natural("16")     # двузначное число
    num7 = Natural("9")      # маленькое число

    print("=" * 60)
    print("ТЕСТИРОВАНИЕ ФУНКЦИЙ КЛАССА NATURAL")
    print("=" * 60)

    # Тест 1: COM_NN_D - сравнение натуральных чисел
    print("\n1. ТЕСТИРОВАНИЕ СРАВНЕНИЯ НАТУРАЛЬНЫХ ЧИСЕЛ (COM_NN_D):")
    print(f"   {num1} сравнить с {num2} = {num1.COM_NN_D(num2)}")  # 1 (2 < 25)
    print(f"   {num4} сравнить с {num6} = {num4.COM_NN_D(num6)}")  # 2 (87 > 16)
    print(f"   {num5} сравнить с {num5} = {num5.COM_NN_D(num5)}")  # 0 (0 == 0)

    # Тест 2: NZER_N_B - проверка на ноль
    print("\n2. ТЕСТИРОВАНИЕ ПРОВЕРКИ НА НОЛЬ (NZER_N_B):")
    print(f"   Число {num1} не равно нулю? {num1.NZER_N_B()}")  # да
    print(f"   Число {num5} не равно нулю? {num5.NZER_N_B()}")  # нет
    print(f"   Число {num6} не равно нулю? {num6.NZER_N_B()}")  # да

    # Тест 3: ADD_1N_N - добавление 1
    print("\n3. ТЕСТИРОВАНИЕ ДОБАВЛЕНИЯ 1 (ADD_1N_N):")
    print(f"   {num1} + 1 = {num1.ADD_1N_N()}")  # 3
    print(f"   {num5} + 1 = {num5.ADD_1N_N()}")  # 1
    print(f"   {num3} + 1 = {num3.ADD_1N_N()}")  # 1000

    # Тест 4: ADD_NN_N - сложение натуральных чисел
    print("\n4. ТЕСТИРОВАНИЕ СЛОЖЕНИЯ НАТУРАЛЬНЫХ ЧИСЕЛ (ADD_NN_N):")
    print(f"   {num1} + {num2} = {num1.ADD_NN_N(num2)}")  # 27
    print(f"   {num3} + {num4} = {num3.ADD_NN_N(num4)}")  # 1086
    print(f"   {num5} + {num7} = {num5.ADD_NN_N(num7)}")  # 9

    # Тест 5: SUB_NN_N - вычитание натуральных чисел
    print("\n5. ТЕСТИРОВАНИЕ ВЫЧИТАНИЯ НАТУРАЛЬНЫХ ЧИСЕЛ (SUB_NN_N):")
    print(f"   {num2} - {num1} = {num2.SUB_NN_N(num1)}")  # 23
    print(f"   {num4} - {num6} = {num4.SUB_NN_N(num6)}")  # 71
    print(f"   {num7} - {num1} = {num7.SUB_NN_N(num1)}")  # 7

    # Тест 6: MUL_ND_N - умножение на цифру
    print("\n6. ТЕСТИРОВАНИЕ УМНОЖЕНИЯ НА ЦИФРУ (MUL_ND_N):")
    print(f"   {num1} * 5 = {num1.MUL_ND_N(5)}")  # 10
    print(f"   {num4} * 3 = {num4.MUL_ND_N(3)}")  # 261
    print(f"   {num7} * 9 = {num7.MUL_ND_N(9)}")  # 81

    # Тест 7: MUL_Nk_N - умножение на 10^k
    print("\n7. ТЕСТИРОВАНИЕ УМНОЖЕНИЯ НА 10^k (MUL_Nk_N):")
    print(f"   {num1} * 10^2 = {num1.MUL_Nk_N(2)}")  # 200
    print(f"   {num7} * 10^3 = {num7.MUL_Nk_N(3)}")  # 9000
    print(f"   {num2} * 10^1 = {num2.MUL_Nk_N(1)}")  # 250

    # Тест 8: MUL_NN_N - умножение натуральных чисел
    print("\n8. ТЕСТИРОВАНИЕ УМНОЖЕНИЯ НАТУРАЛЬНЫХ ЧИСЕЛ (MUL_NN_N):")
    print(f"   {num6} * {num2} = {num6.MUL_NN_N(num2)}")  # 400
    print(f"   {num4} * {num4} = {num4.MUL_NN_N(num4)}")  # 7569
    print(f"   {num1} * {num7} = {num1.MUL_NN_N(num7)}")  # 18

    # Тест 9: SUB_NDN_N - вычитание умноженного числа
    print("\n9. ТЕСТИРОВАНИЕ ВЫЧИТАНИЯ УМНОЖЕННОГО ЧИСЛА (SUB_NDN_N):")
    print(f"   {num4} - ({num2} * 2) = {num4.SUB_NDN_N(num2, 2)}")  # 87 - (25 * 2) = 37
    print(f"   {num3} - ({num1} * 5) = {num3.SUB_NDN_N(num1, 5)}")  # 999 - (2 * 5) = 989
    print(f"   {num7} - ({num1} * 3) = {num7.SUB_NDN_N(num1, 3)}")  # 9 - (2 * 3) = 3

    # Тест 10: DIV_NN_Dk - нахождение первой цифры частного
    print("\n10. ТЕСТИРОВАНИЕ НАХОЖДЕНИЯ ПЕРВОЙ ЦИФРЫ ЧАСТНОГО (DIV_NN_Dk):")
    print(f"   {num4} / {num6} = {num4.DIV_NN_Dk(num6)}")  # 87 / 16: цифра 5, позиция 0 (единицы)
    print(f"   {num3} / {num4} = {num3.DIV_NN_Dk(num4)}")  # 999 / 87: цифра 1, позиция 1 (десятки)
    print(f"   {num7} / {num1} = {num7.DIV_NN_Dk(num1)}")  # 9 / 2: цифра 4, позиция 0 (единицы)

    # Тест 11: DIV_NN_N - деление натуральных чисел
    print("\n11. ТЕСТИРОВАНИЕ ДЕЛЕНИЯ НАТУРАЛЬНЫХ ЧИСЕЛ (DIV_NN_N):")
    print(f"   {num3} / {num2} = {num3.DIV_NN_N(num2)}")  # 999 / 25 = 39
    print(f"   {num4} / {num1} = {num4.DIV_NN_N(num1)}")  # 87 / 2 = 43
    print(f"   {num6} / {num7} = {num6.DIV_NN_N(num7)}")  # 16 / 9 = 1

    # Тест 12: MOD_NN_N - остаток от деления
    print("\n12. ТЕСТИРОВАНИЕ ОСТАТКА ОТ ДЕЛЕНИЯ (MOD_NN_N):")
    print(f"   {num3} % {num2} = {num3.MOD_NN_N(num2)}")  # 999 % 25 = 24
    print(f"   {num4} % {num1} = {num4.MOD_NN_N(num1)}")  # 87 % 2 = 1
    print(f"   {num6} % {num7} = {num6.MOD_NN_N(num7)}")  # 16 % 9 = 7

    # Тест 13: GCF_NN_N - наибольший общий делитель
    print("\n13. ТЕСТИРОВАНИЕ НАИБОЛЬШЕГО ОБЩЕГО ДЕЛИТЕЛЯ (GCF_NN_N):")
    print(f"   НОД({num3}, {num4}) = {num3.GCF_NN_N(num4)}")  # НОД(999, 87) = 3
    print(f"   НОД({num2}, {num4}) = {num2.GCF_NN_N(num4)}")  # НОД(25, 87) = 1
    print(f"   НОД({num6}, {num7}) = {num6.GCF_NN_N(num7)}")  # НОД(16, 9) = 1

    # Тест 14: LCM_NN_N - наименьшее общее кратное
    print("\n14. ТЕСТИРОВАНИЕ НАИМЕНЬШЕГО ОБЩЕГО КРАТНОГО (LCM_NN_N):")
    print(f"   НОК({num1}, {num2}) = {num1.LCM_NN_N(num2)}")  # НОК(2, 25) = 50
    print(f"   НОК({num2}, {num4}) = {num2.LCM_NN_N(num4)}")  # НОК(25, 87) = 2175
    print(f"   НОК({num6}, {num7}) = {num6.LCM_NN_N(num7)}")  # НОК(16, 9) = 144

    print("\n" + "=" * 60)
    print("ТЕСТИРОВАНИЕ НАТУРАЛЬНЫХ ЧИСЕЛ ЗАВЕРШЕНО!")
    print("=" * 60)

tests_for_naturales()
